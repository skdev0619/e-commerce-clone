# 캐시 적용 보고서

## 1. 배경

> 대용량 트래픽 환경에서는 높은 조회 성능과 안정적인 서버 운영이 필수적이다<br>
> 이를 위해, db 조회에 대한 부담을 줄이고, 사용자 요청에 빠르게 응답할 수 있도록 **캐시**를 적용하여 조회 성능을 개선하고자 한다<br> 
> 캐시를 적용하여 반복적인 데이터 조회를 효율적으로 처리하고, 서버 자원 소모를 최소화하며, 사용자 경험을 향상시키고자 한다<br>

## 2. 캐시 적용 조건

캐시를 적용하기 위한 주요 조건은 다음과 같습니다:

- **조회 비용이 높다**  
  데이터 조회에 시간이 많이 걸리거나 복잡한 계산으로 CPU 리소스를 소모하는 경우, 캐시를 사용하여 성능을 개선할 수 있다.<br>
  예를 들어, 데이터베이스 조회가 오래 걸리거나 서버에서 복잡한 데이터 가공으로 인한 리소스 소모가 심하거나, 외부 API 호출이 필요한 경우, 캐시를 통해 빠르게 결과를 반환할 수 있다

- **조회 빈도가 높다**  
  동일한 데이터를 자주 조회하는 경우, 캐시를 사용하면 반복적인 조회에 대한 성능 저하를 방지할 수 있다.<br> 메인 화면이나 자주 요청되는 기능에서 자주 조회되는 데이터는 캐시를 통해 빠르게 응답할 수 있어 사용자 경험을 개선할 수 있다.

- **자주 변경되지 않는다**  
  캐시된 데이터가 자주 변경되지 않으면, 캐시의 유효성을 쉽게 관리할 수 있다.<br> 자주 변동되는 데이터는 캐시의 유효성이 떨어지고, 캐시를 다시 쓰는 비용이 자주 발생하므로 변동이 적은 데이터를 대상으로 사용하는 것이 효과적이다.

## 3. 캐시 적용 대상 및 전략 선택
### `인기 상품 조회에 캐시 적용` 
- 인기 상품 조회는 DB 집계 조회가 필요한 작업이기 때문에 조회 비용이 높으며, 주로 메인 화면에 노출되어 조회 빈도가 높다.  
- 고객은 완벽하게 실시간인 데이터보다 대략적인 상품 판매 추이를 파악하기를 원하며, 해당 데이터 역시 자주 변경되지 않는다.
#### 따라서 `캐시를 적용하여 조회 성능을 개선` 하기로 결정하였다`

### `Read Through 전략 선택`
- 인기 상품 조회는 조회 비용이 높아, 캐시가 비어 있을 때마다 db 부하가 가는 **Cache Aside** 방식은 적합하지 않다
#### 따라서 `항상 캐시에서 데이터를 조회하는 **Read Through** 전략을 적용`하기로 결정하였다

## 4. 상세 구현 설명
### 1) 캐시 버전 설정
`현재 날짜를 기준으로 캐시의 버전`을 설정한다.<br>
예를 들어 5월 9일의 경우, `best-selling-products:2025-05-09`로 캐시 이름을 설정한다.

#### ex) BestSellingProductsQueryService.kt
```kotlin
@GlobalCacheable(
        name = "best-selling-products",
        key = "T(java.time.LocalDate).now().toString()",
        expireMinute = 1560    //26시간
)
```

### 2) 캐시 조회 우선 순위
#### ex) GlobalCacheAspect.kt
```kotlin
return cacheTemplate.get(cacheName)
    ?: cacheTemplate.get("${cacheName}-failover")
    ?: run {
        val data = joinPoint.proceed()
        cacheTemplate.put(cacheName, data, Duration.ofMinutes(annotation.expireMinute))
        return data
}
```
1. 현재 날짜 버전의 캐시가 존재하면 해당 캐시에서 조회한다
2. 현재 날짜 버전의 캐시가 없으면, failover 캐시에서 조회한다
3. 캐시가 없는 경우, DB에서 조회 후 현재 날짜 버전 캐시에 저장한다

### 3) 스케쥴러에서 내일 날짜의 failover 캐시, 캐시를 생성한다.
1. 스케쥴러는 매일 오후 10시에 실행하여 내일 날짜 버전의 캐시를 생성한다.
2. 스케줄러는 집계 데이터 생성 전에 오늘 날짜 버전 캐시 데이터를 기반으로 내일 날짜의 failover 캐시를 생성한다
  - 스케쥴러의 실행이 오늘 안에 끝나지 않거나, 스케쥴러 실행에 문제가 생겨서 내일 날짜 버전의 캐시가 생성이 안될 수 있다
  - 이를 대비하여 내일 날짜의 failover 캐시를 먼저 생성하고, 데이터는 오늘 날짜의 캐시 데이터를 저장한다.
3. 오늘 날짜 데이터를 기준으로 집계 데이터를 생성한 후, 내일 날짜 버전의 캐시를 생성한다

### 참고
위의 내용들을 정리한 캐시 라이프 사이클은 아래와 같다.  
#### ex) 5월 8일과 5월 9일 사이의 캐시의 라이프 사이클
![cache_lifecycle.png](/docs/image/cache_lifecycle.png)

## 5. 성능 비교
### 캐시 적용 before 
![캐시적용_before.png](/docs/image/캐시적용_before.png)
- 평균 응답 시간: 717.88ms
- 90%의 요청은 1.47s 이내, 95%의 요청은 1.55s 이내에 완료

### 캐시 적용 
![캐시적용_after.png](/docs/image/캐시적용_after.png)
- 평균 응답 시간: 116.8ms
- 90%의 요청은 302.7ms 이내, 95%의 요청은 376.86ms 이내에 완료

### 캐시 적용 before vs 캐시 적용 실행 시간 비교
| 구분   | 평균 응답 시간 | p90 응답 시간 | p95 응답 시간 |
|------|----------|-----------|-----------|
| 캐시 X | 717.88ms | 1.47s     | 1.55s     |
| 캐시 O | 116.8ms  | 302.7ms   | 376.86ms  |

`모든 지표에서 캐시 적용 후의 응답 시간이 더 빨라진 것을 확인할 수 있다`